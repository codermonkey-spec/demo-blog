### 一.正则表达式介绍

正则表达式是一种字符串匹配利器，主要功能就在`字符串`的`查找`，`替换`，`校验`上。

### 二.js 中的正则表达式

1. String 对象上的方法

`match`: 匹配到为一个匹配到的项的数组，如果一个都没有匹配到就为 null

`replace`,`search`,`split`

2. RegExp 上的方法

`exec`: 他会返回找到的第一个匹配的项（包含匹配到的项的下标），如果没有找到就返回 null

`test`: 匹配了就返回 true，否则返回 false

### 三.修饰符

1. `g` 全局匹配

2. `i` 忽略大小写

3. `m` 多行匹配

### 四.正则表达式语法

#### 4.1 `.`字符 : 匹配任意一个单个字符

```js
const str = `
  sales1.xls
  orders3.xls
  sa1.xls
`;
const result = str.match(/sales./g); // ['sales1']

// ['sales1', index: 3, input: '\n  sales1.xls\n  orders3.xls\n  sa1.xls\n', groups: undefined]
/sales./g.exec(str);
```

#### 4.2 特殊字符转义 `\`

当我们需要匹配在正则表达式中有特殊意义的字符就需要使用`\`这个转义字符

例如: `\`,`.`,`[`,`]`等等

```js
const str = ` 
  sales1.xls
  orders3.xls
  sa1.xls`;
const result = str.match(/sa1\.xls/g); // ['sa1.xls']
```

#### 4.3 匹配一组字符 `[]`

```js
const str = `
  sales1.xls
  orders3.xls
  sa1.xls
  na1.xls
  na2.xls
`;
const result = str.match(/[ns]a.\.xls/g); //  ['sa1.xls', 'na1.xls', 'na2.xls']
```

常见字符区间 `0-9`,`a-z`,`A-Z`

```js
// 字符集合区间
const str = `
  sales1.xls
  orders3.xls
  sa1.xls
  na1.xls
  na2.xls
`;
const result = str.match(/[ns]a[0-9]\.xls/g); //  ['sa1.xls', 'na1.xls', 'na2.xls']
```

#### 4.4 取非匹配 `^`

```js
const str = `
  sales1.xls
  orders3.xls
  sa1.xls
  na1.xls
  na2.xls
  nam.xls
`;
const result = str.match(/[ns]a[^0-9]\.xls/g); // ['nam.xls']
```

#### 4.5. 匹配空白字符

```js

[\b]: 回退(并删除)一个字符(Backspace键)

\f : 换页符

\n : 换行符

\r : 回车符

\t : 制表符(Tab键)

\v : 垂直制表符

```

#### 4.6 类元字符(代表某一类特定的字符)

```js
\d : 任何一个数字字符(等价于[0-9]);
\D : 任何一个非数字字符(等价于[^0-9]);
\w : 任何一个字母数字字符(大小写均可)或下划线字符(等价于[a-zA-Z0-9_])
\W : 任何一个非字母数字字符(大小写均可)或下划线字符(等价于[^a-zA-Z0-9])
\s : 任何一个空白字符(等价于[\f\n\r\t\v])
\S: 任何一个非空白字符(等价于[^\f\n\r\t\v])
```

#### 4.7 重复匹配 `+`

`+` 可以匹配一个或多个字符(至少要有一个)
`*` 可以匹配零个或多个字符(可以为零个)
`?` 可以匹配零个或者一个字符，最多不超过一个
`{1,3}` 可以匹配出现 1-3 次的字符.`{3}`表示可以匹配出现三次的字符

```js
const str = `123123msdas`;
const result = str.match(/\d+/g); // ['123123']
```

#### 4.8 贪婪模式和怠惰模式

`+`,`*`,`{}`都是贪婪型匹配，也就是说他们会尽可能的匹配

```js
const str = `This offer is not available to customers living in <B>AK</B> and <B>HI</B>`;
const result = str.match(/<[Bb]>.*<\/[Bb]>/g); // ['<B>AK</B> and <B>HI</B>']
```

当我们想尽可能少的匹配字符的时候就需要使用怠惰型匹配

`+?`,`*?`,`{}?`

```js
const str = `This offer is not available to customers living in <B>AK</B> and <B>HI</B>`;
const result = str.match(/<[Bb]>.*?<\/[Bb]>/g); //) ['<B>AK</B>', '<B>HI</B>']
```

#### 4.9 位置匹配

`单词边界`: `\b`;

`\b`:匹配一个和`\W`能匹配的字符

`\B`:非单词边界

```js
const str = `The cat scattered his food all over the room`;
const result = str.replace(/\bcat\b/g, "dog");
console.log(result); // The dog scattered his food all over the room
```

`字符串边界`:主要是`^`以什么字符开头,`$`:以什么字符结尾

#### 4.10 子表达式`()`

当我们想要把一个短语变成一个整体时就需要使用子表达式;

```js
// 这里其实匹配的是&nbsp;;;
const str = `The cat scattered his &nbsp;&nbsp; food all over the room`;
const result = str.match(/&nbsp;{2,}/g, "dog"); // null
```

```js
const str = `The cat scattered his &nbsp;&nbsp; food all over the room`;
const result = str.match(/(&nbsp;){2,}/g, "dog"); // ['&nbsp;&nbsp;']
```

#### 4.11 回溯引用

`\1`:表示和第一个字表达式匹配到的内容一样

```js
const str = `
    The cat 
      <h2>scattered his</h2> &nbsp;&nbsp;
      <h1>food all</h1> 
      <h2>over the</h3> room
`;
const result = str.match(/<[hH]([1-6])>.*?<\/[hH]\1>/g); //  ['<h2>scattered his</h2>', '<h1>food all</h1>']
```

#### 4.12 前后查找

`?=`: 向前查找

```js
// 向前查找直到出现冒号(但是不包含冒号)
const str = `
    https://www.baidu.com
    http://www.taobao.com
    ftp://mail.com;
`;
const result = str.match(/.+(?=:)/g); //  ['    https', '    http', '    ftp']
```

`?<=`: 向后查找
